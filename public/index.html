<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>City Simulation - Roads and Energy</title>
    <script src="/socket.io/socket.io.js"></script>
    <!-- Add Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <link rel="stylesheet" href="style.css">
    <style>
        /* Estilo general del cuerpo */
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            background-color: #f0f0f0;
            margin: 0;
        }

        /* Reset button styling */
        #reset-button {
            background-color: #FF6B6B;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            width: 100%;
        }

        #reset-button:hover {
            background-color: #FF5252;
        }

        /* Energy bar container */
        h1 {
            font-size: 20px; /* Font size */
            color: #333; /* Text color */
            margin: 0 0 10px 0; /* Spacing below title */
        }

        .energy-bar-container {
            width: 250px;
            height: 25px;
            background-color: #ddd;
            border-radius: 5px;
            margin-bottom: 10px;
            overflow: hidden;
            border: 2px solid black;
        }

        /* Energy bar (variable) */
        .energy-bar {
            height: 100%;
            width: 100%; /* Starts full */
            background-color: #FFFF00; /* Yellow */
            transition: width 0.2s;
        }

        /* Main map */
        .map {
            position: relative;
            width: 800px;
            height: 600px;
            background-color: #e0e0e0;
            border: 2px solid black;
            margin: 0 auto;
        }

        /* General roads */
        .road {
            position: absolute;
            background-color: #808080;
        }

        /* Vertical streets */
        .vertical-road {
            width: 30px;  /* Reverted back to 30px */
            height: 1000px;
        }

        .vertical-road-1 { left: 115px; top: 0; }
        .vertical-road-2 { left: 235px; top: 0; }
        .vertical-road-3 { left: 355px; top: 0; }
        .vertical-road-4 { left: 0px; top: 0; }
        .vertical-road-5 { left: 470px; top: 0; }
        .vertical-road-6 { left: 615px; top: 0; }
        .vertical-road-7 { left: 735px; top: 0; }
        .vertical-road-8 { left: 855px; top: 0; }
        .vertical-road-9 { left: 970px; top: 0; }

        /* Horizontal streets */
        .horizontal-road {
            width: 1000px;
            height: 30px;  /* Reverted back to 30px */
        }

        .horizontal-road-1 { top: 115px; left: 0; }
        .horizontal-road-2 { top: 235px; left: 0; }
        .horizontal-road-3 { top: 355px; left: 0; }
        .horizontal-road-4 { top: 0px; left: 0; }
        .horizontal-road-5 { top: 470px; left: 0; }
        .horizontal-road-6 { top: 615px; left: 0; }
        .horizontal-road-7 { top: 735px; left: 0; }
        .horizontal-road-8 { top: 855px; left: 0; }
        .horizontal-road-9 { top: 970px; left: 0; }

        /* Entry roads from the left */
        .entry-road {
            width: 100px;
            height: 30px;
            background-color: #FF5722;
        }

        .entry-road-1 { top: 115px; left: -100px; }
        .entry-road-2 { top: 235px; left: -100px; }
        .entry-road-3 { top: 355px; left: -100px; }
        .entry-road-4 { top: 470px; left: -100px; }

        /* Exit roads to the right */
        .exit-road {
            width: 100px;
            height: 30px;
            background-color: #4CAF50;
        }

        .exit-road-1 { top: 115px; left: 800px; }
        .exit-road-2 { top: 235px; left: 800px; }
        .exit-road-3 { top: 355px; left: 800px; }
        .exit-road-4 { top: 470px; left: 800px; }

        /* Entry roads from the top */
        .entry-road-top {
            width: 30px;
            height: 100px;
            background-color: #FF9800;
        }

        .entry-road-top-1 { top: -100px; left: 115px; }
        .entry-road-top-2 { top: -100px; left: 235px; }
        .entry-road-top-3 { top: -100px; left: 355px; }
        .entry-road-top-4 { top: -100px; left: 470px; }

        /* Exit roads to the bottom */
        .exit-road-bottom {
            width: 30px;
            height: 100px;
            background-color: #2196F3;
        }

        .exit-road-bottom-1 { top: 600px; left: 115px; }
        .exit-road-bottom-2 { top: 600px; left: 235px; }
        .exit-road-bottom-3 { top: 600px; left: 355px; }
        .exit-road-bottom-4 { top: 600px; left: 470px; }

        /* Car style */
        .car {
            position: absolute;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #333;
            transform: rotate(0deg);
            transition: transform 0.2s;
        }

        /* Charging station style */
        .station {
            position: absolute;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: #FFD700;
            background-color: transparent;
            border-radius: 0;
        }



        /* Money indicator style */
        .money-indicator {
            margin-bottom: 8px;
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }

        /* Delivery item styles */
        .delivery-item {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #FFD700;
            border: 2px solid #FFA500;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            color: #333;
        }

        /* Item indicator in UI */
        .item-indicator {
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: bold;
            color: #666;
            line-height: 1.2;
        }

        /* Delivery destination highlight */
        .delivery-destination {
            animation: deliveryPulse 2s infinite;
        }

        @keyframes deliveryPulse {
            0% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(255, 215, 0, 0); }
            100% { box-shadow: 0 0 0 0 rgba(255, 215, 0, 0); }
        }


        
        /* Station info panel style */
        .station-info-panel {
            position: absolute;
            background-color: #fff;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 10px;
            font-size: 12px;
            color: #333;
            white-space: nowrap;
            z-index: 1000;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            min-width: 200px;
            max-width: 220px;
        }

        /* Station info buttons */
        .station-info-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 6px 8px;
            margin: 1px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: bold;
            transition: background-color 0.3s;
            width: 48%;
            display: inline-block;
            box-sizing: border-box;
            float: left;
        }

        /* Button container for 2x2 grid */
        .button-container {
            width: 100%;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .button-container::after {
            content: "";
            display: table;
            clear: both;
        }

        .station-info-button:hover {
            background-color: #45a049;
        }

        .station-info-button.price {
            background-color: #FF9800;
        }

        .station-info-button.price:hover {
            background-color: #F57C00;
        }

        .station-info-button.time {
            background-color: #2196F3;
        }

        .station-info-button.time:hover {
            background-color: #1976D2;
        }

        .station-info-button.sockets {
            background-color: #9C27B0;
        }

        .station-info-button.sockets:hover {
            background-color: #7B1FA2;
        }

        .station-info-button.status {
            background-color: #607D8B;
        }

        .station-info-button.status:hover {
            background-color: #455A64;
        }

        /* Info display area */
        .station-info-display {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 8px;
            margin-top: 8px;
            font-size: 11px;
            color: #333;
            text-align: center;
            min-height: 20px;
        }

        .player-name {
            pointer-events: none;
            user-select: none;
        }

        /* Add charging animation */
        @keyframes charging {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.8; }
            100% { transform: scale(1); opacity: 1; }
        }

        .station.charging {
            animation: charging 1s infinite;
            box-shadow: 0 0 10px #FFD700;
        }

        /* Remove charge button styles */
        .charge-button {
            position: absolute;
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        .charge-button:hover {
            background-color: #45a049;
        }

        .charge-button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        /* Update parking lot styles */
        .parking-lot {
            position: absolute;
            width: 30px;
            height: 30px;
            background-color: #666;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 2px;
        }

        .parking-spot {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: white;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .parking-spot.occupied {
            opacity: 1;
        }

        .parking-count {
            position: absolute;
            top: -18px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 10px;
        }

        /* Add cancel button styles */
        .cancel-charge-button {
            position: absolute;
            background-color: #ff4444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            z-index: 1000;
            transition: opacity 0.3s;
        }

        .cancel-charge-button:hover {
            background-color: #cc0000;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .ui-container {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            max-width: 300px;
        }

        .map-container {
            width: 100vw;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }

        .map {
            position: relative;
            width: 1000px;
            height: 1000px;
            background-color: #e0e0e0;
            border: 2px solid black;
            transform-origin: center center;
            /* Scale to fit viewport with padding for entry points */
            scale: calc(min(90vw, 90vh) / 1000);
        }

        /* Entry/Exit road styles - all 30x30 and drivable */
        .entry-road-left {
            position: absolute;
            width: 30px;
            height: 30px;
            left: -30px;
            top: 485px;
            background-color: #FF5722;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            color: white;
        }
        .exit-road-right {
            position: absolute;
            width: 30px;
            height: 30px;
            left: 1000px;
            top: 485px;
            background-color: #4CAF50;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            color: white;
        }
        .entry-road-top {
            position: absolute;
            width: 30px;
            height: 30px;
            left: 485px;
            top: -30px;
            background-color: #FF9800;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            color: white;
        }
        .exit-road-bottom {
            position: absolute;
            width: 30px;
            height: 30px;
            left: 485px;
            top: 1000px;
            background-color: #2196F3;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
            color: white;
        }

        .branding .logo-container img {
            height: 75px !important;   /* make them ~6Ã— smaller */
            width: 80px !important;
            object-fit: contain;
        }

        /* Make sure the UI panel sits below the branding header */
        .ui-container {
            top: 90px !important;
        }
    </style>
    <!-- <script src="/socket.io/socket.io.js"></script> -->
</head>
<body>
    <div class="ui-container">
        <div class="player-name-display" id="player-name-display" style="
            font-size: 18px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 10px;
            text-align: center;
            padding: 8px;
            background-color: rgba(52, 152, 219, 0.1);
            border-radius: 4px;
            border: 1px solid rgba(52, 152, 219, 0.3);
        ">Player</div>
        
        <h1 style="margin: 0 0 10px 0; font-size: 20px;">Energy Level</h1>
        <div class="energy-bar-container">
            <div class="energy-bar" id="energy-bar"></div>
        </div>

        <div class="money-indicator" id="money-indicator">Budget: $100</div> <!-- Money indicator -->
        
        <div class="item-indicator" id="item-indicator">No item</div> <!-- Item indicator -->

        <button id="reset-button">Reset Car</button> <!-- Reset button -->

        <header class="branding">
        <div class="logo-container">
            <img src="Rice_logo.png" alt="Logo 1">
            <img src="Purdue_logo.png" alt="Logo 2">
            <img src="NSF_logo.png" alt="Logo 3">
        </div>
        <p class="award-text">Supported by NSF Award BCS #2323732</p>
        </header>

    </div>



    <div class="map-container">
        <div class="map" id="map">
            <!-- Vertical streets (internal grid) -->
            <div class="road vertical-road vertical-road-1"></div>
            <div class="road vertical-road vertical-road-2"></div>
            <div class="road vertical-road vertical-road-3"></div>
            <div class="road vertical-road vertical-road-4"></div>
            <div class="road vertical-road vertical-road-5"></div>
            <div class="road vertical-road vertical-road-6"></div>
            <div class="road vertical-road vertical-road-7"></div>
            <div class="road vertical-road vertical-road-8"></div>
            <div class="road vertical-road vertical-road-9"></div>

            <!-- Horizontal streets (internal grid) -->
            <div class="road horizontal-road horizontal-road-1"></div>
            <div class="road horizontal-road horizontal-road-2"></div>
            <div class="road horizontal-road horizontal-road-3"></div>
            <div class="road horizontal-road horizontal-road-4"></div>
            <div class="road horizontal-road horizontal-road-5"></div>
            <div class="road horizontal-road horizontal-road-6"></div>
            <div class="road horizontal-road horizontal-road-7"></div>
            <div class="road horizontal-road horizontal-road-8"></div>
            <div class="road horizontal-road horizontal-road-9"></div>

            <!-- Entry/Exit points -->
            <div class="road entry-road entry-road-left">4</div>
            <div class="road exit-road exit-road-right">2</div>
            <div class="road entry-road-top entry-road-top">1</div>
            <div class="road exit-road-bottom exit-road-bottom">3</div>
        </div>
    </div>

    <script>


const socket = io();
let playerId;
let players = new Map();

// Initial variables (will be set when receiving game state)
let carPositionX;
let carPositionY;
let energy = 100;
let money = 100;
let adminBudget = 100; // Store admin budget setting
let numberstations = 1;
let meanPrice = 30;
let stationSize = 15;
let velocity = 5;
//let resetPosition = { x: 479, y: 242 };
const mapSize = 1000;

// Delivery system variables
let hasItem = false;
let currentItem = null;
let deliveryPoints = [];
let originalStartingPoint = null; // Store where player started with current item
const DELIVERY_REWARD = 50;
const energyBar = document.getElementById('energy-bar');
const moneyIndicator = document.getElementById('money-indicator');
const itemIndicator = document.getElementById('item-indicator');
const map = document.getElementById('map');

const getInitialParameters = async () => {
    try {
        const response = await fetch('/admin-parameters');
        const initialParameters = await response.json();
        stationSize = parseInt(initialParameters.stationSize);
        numberstations = parseInt(initialParameters.stationCount);
        meanPrice = parseFloat(initialParameters.meanPrice);
        adminBudget = parseInt(initialParameters.playerBudget); // Store admin budget
        console.log('getting params from server successfully!');
        console.log(numberstations);
        createChargingStations(numberstations, meanPrice);
    } catch (error) {
        console.log('there was an issue getting values from server. Using default values...', error);
    }
}

getInitialParameters();

// Initialize delivery system
const initializeDeliverySystem = () => {
    deliveryPoints = [
        { id: 'top', x: 485, y: -15, name: 'Entry Point 1', color: '#FF9800', pointNumber: 1 },      // Top (1)
        { id: 'right', x: 1015, y: 485, name: 'Entry Point 2', color: '#4CAF50', pointNumber: 2 },  // Right (2)
        { id: 'bottom', x: 485, y: 1015, name: 'Entry Point 3', color: '#2196F3', pointNumber: 3 }, // Bottom (3)
        { id: 'left', x: -15, y: 485, name: 'Entry Point 4', color: '#FF5722', pointNumber: 4 }     // Left (4)
    ];
    
    // Don't spawn items automatically since players start with items
    updateItemIndicator();
};

// Function to spawn a random item at a random delivery point
const spawnRandomItem = () => {
    // Remove any existing items
    document.querySelectorAll('.delivery-item').forEach(item => item.remove());
    
    // Don't spawn if player already has an item
    if (hasItem) return;
    
    // Choose random delivery point for pickup
    const pickupPoint = deliveryPoints[Math.floor(Math.random() * deliveryPoints.length)];
    
    // Choose random different delivery point for destination
    let destinationPoint;
    do {
        destinationPoint = deliveryPoints[Math.floor(Math.random() * deliveryPoints.length)];
    } while (destinationPoint.id === pickupPoint.id);
    
    // Create item element
    const itemElement = document.createElement('div');
    itemElement.className = 'delivery-item';
    itemElement.textContent = 'ðŸ“¦';
    itemElement.style.left = `${pickupPoint.x}px`;
    itemElement.style.top = `${pickupPoint.y}px`;
    itemElement.dataset.pickupId = pickupPoint.id;
    itemElement.dataset.destinationId = destinationPoint.id;
    itemElement.dataset.destinationName = destinationPoint.name;
    
    map.appendChild(itemElement);
    
    // Highlight destination point
    highlightDestination(destinationPoint.id);
};

// Function to highlight destination point
const highlightDestination = (pointId) => {
    // Remove previous highlights
    document.querySelectorAll('.delivery-destination').forEach(el => {
        el.classList.remove('delivery-destination');
    });
    
    // Find and highlight the destination point
    const destinationElements = {
        'left': document.querySelector('.entry-road-left'),
        'right': document.querySelector('.exit-road-right'),
        'top': document.querySelector('.entry-road-top'),
        'bottom': document.querySelector('.exit-road-bottom')
    };
    
    if (destinationElements[pointId]) {
        destinationElements[pointId].classList.add('delivery-destination');
    }
};

// Function to update item indicator
const updateItemIndicator = () => {
    if (hasItem && currentItem) {
        itemIndicator.textContent = `Carrying item â†’ Deliver to ${currentItem.destinationName}`;
        itemIndicator.style.color = '#FF8C00';
    } else {
        itemIndicator.textContent = 'No item - Find a delivery item to pick up';
        itemIndicator.style.color = '#666';
    }
};

// Function to check for item pickup/delivery
const checkDeliveryInteraction = () => {
    const tolerance = 25;
    
    if (!hasItem) {
        // Check for item pickup
        const items = document.querySelectorAll('.delivery-item');
        items.forEach(item => {
            const itemX = parseInt(item.style.left);
            const itemY = parseInt(item.style.top);
            
            if (Math.abs(carPositionX - itemX) < tolerance && Math.abs(carPositionY - itemY) < tolerance) {
                // Pick up item
                hasItem = true;
                currentItem = {
                    destinationId: item.dataset.destinationId,
                    destinationName: item.dataset.destinationName
                };
                
                // Remove item from map
                item.remove();
                
                // Update UI
                updateItemIndicator();
                showNotification(`Picked up delivery item! Deliver to ${currentItem.destinationName}`, 'info');
                
                // Get pickup point number
                const pickupPoint = deliveryPoints.find(point => point.x === itemX && point.y === itemY);
                
                // Emit pickup event
                socket.emit('itemPickup', {
                    playerId: playerId,
                    pickupPoint: pickupPoint ? pickupPoint.pointNumber : 'unknown',
                    itemDestination: currentItem.destinationId,
                    destinationPoint: deliveryPoints.find(point => point.id === currentItem.destinationId)?.pointNumber || 'unknown',
                    timestamp: Date.now()
                });
            }
        });
    } else {
        // Check for delivery
        const destination = deliveryPoints.find(point => point.id === currentItem.destinationId);
        if (destination) {
            if (Math.abs(carPositionX - destination.x) < tolerance && Math.abs(carPositionY - destination.y) < tolerance) {
                // Deliver item
                money += DELIVERY_REWARD;
                hasItem = false;
                
                // Remove destination highlight
                document.querySelectorAll('.delivery-destination').forEach(el => {
                    el.classList.remove('delivery-destination');
                });
                
                // Update UI
                updateMoneyIndicator();
                updateItemIndicator();
                showNotification(`Item delivered! +$${DELIVERY_REWARD}`, 'success');
                
                // Emit delivery event
                socket.emit('itemDelivery', {
                    playerId: playerId,
                    destinationId: currentItem.destinationId,
                    deliveryPoint: destination.pointNumber,
                    reward: DELIVERY_REWARD,
                    timestamp: Date.now()
                });
                
                currentItem = null;
                originalStartingPoint = null; // Clear old starting point
                
                // Assign new item to player after a short delay
                setTimeout(() => {
                    startWithInitialItem();
                }, 2000);
            }
        }
    }
};

initializeDeliverySystem();

// Function to start player with an initial item
const startWithInitialItem = () => {
    if (hasItem) return; // Don't override if already has item
    
    // Store current position as the original starting point for this delivery
    originalStartingPoint = {
        x: carPositionX,
        y: carPositionY
    };
    
    // Choose random destination different from current position
    let possibleDestinations = deliveryPoints.filter(point => {
        const distance = Math.abs(carPositionX - point.x) + Math.abs(carPositionY - point.y);
        return distance > 100; // Make sure it's not the same point they're starting at
    });
    
    if (possibleDestinations.length === 0) {
        possibleDestinations = deliveryPoints; // Fallback to any destination
    }
    
    const destinationPoint = possibleDestinations[Math.floor(Math.random() * possibleDestinations.length)];
    
    // Set up initial item
    hasItem = true;
    currentItem = {
        destinationId: destinationPoint.id,
        destinationName: destinationPoint.name
    };
    
    // Highlight destination
    highlightDestination(destinationPoint.id);
    
    // Update UI
    updateItemIndicator();
    showNotification(`Starting with delivery item! Deliver to ${currentItem.destinationName}`, 'info');
    
    // Log initial item assignment
    socket.emit('itemAssigned', {
        playerId: playerId,
        destinationPoint: destinationPoint.pointNumber,
        destinationPointName: destinationPoint.name,
        timestamp: Date.now()
    });
};

        // Handle initial game state
        socket.on('gameState', (data) => {
            playerId = data.playerId;
            const currentPlayer = data.players.find(p => p.id === playerId);
            
            // Set initial position from server
            carPositionX = currentPlayer.positionX;
            carPositionY = currentPlayer.positionY;

            // Set money from server and update UI
            money = currentPlayer.money;
            updateMoneyIndicator();

            // Display player name in UI
            const playerNameDisplay = document.getElementById('player-name-display');
            if (playerNameDisplay && currentPlayer.name) {
                playerNameDisplay.textContent = currentPlayer.name;
                playerNameDisplay.style.color = currentPlayer.color || '#2c3e50';
            }

            // Create all players including self
            data.players.forEach(player => {
                createPlayerCar(player);
                players.set(player.id, player);
            });
            
            // Create charging stations from server data
            createChargingStationsFromServer(data.stations);
            
            // Start with an item after everything is loaded
            setTimeout(() => {
                startWithInitialItem();
            }, 500);
        });

        // Handle station updates from admin
        socket.on('stationsUpdated', (data) => {
            // Clear existing stations
            document.querySelectorAll('.station').forEach(el => el.remove());
            document.querySelectorAll('.parking-lot').forEach(el => el.remove());
            document.querySelectorAll('.station-info-panel').forEach(el => el.remove());
            
            // Create new stations
            createChargingStationsFromServer(data.stations);
        });

        function createPlayerCar(player) {
            const playerCar = document.createElement('div');
            playerCar.id = `car-${player.id}`;
            playerCar.className = 'car';
            playerCar.style.position = 'absolute';
            playerCar.style.left = player.positionX + "px";
            playerCar.style.top = player.positionY + "px";
            playerCar.style.color = player.color;

            // Add car icon
            const carIcon = document.createElement('i');
            carIcon.className = 'fas fa-car';
            playerCar.appendChild(carIcon);

            // Create player name label
            const nameLabel = document.createElement('div');
            nameLabel.className = 'player-name';
            nameLabel.textContent = player.name;
            nameLabel.style.position = 'absolute';
            nameLabel.style.top = '-20px';
            nameLabel.style.left = '50%';
            nameLabel.style.transform = 'translateX(-50%)';
            nameLabel.style.color = 'black';
            nameLabel.style.fontSize = '12px';
            nameLabel.style.fontWeight = 'bold';
            nameLabel.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
            nameLabel.style.padding = '2px 5px';
            nameLabel.style.borderRadius = '3px';
            nameLabel.style.whiteSpace = 'nowrap';

            playerCar.appendChild(nameLabel);
            map.appendChild(playerCar);
        }

        // Handle new player joining
        socket.on('playerJoined', (player) => {
            createPlayerCar(player);
            players.set(player.id, player);
        });

        // Handle player movement
        socket.on('playerMoved', (data) => {
            const playerCar = document.getElementById(`car-${data.id}`);
            if (playerCar) {
                // Update position regardless of charging state
                playerCar.style.left = data.positionX + "px";
                playerCar.style.top = data.positionY + "px";
                
                if (players.has(data.id)) {
                    const player = players.get(data.id);
                    player.energy = data.energy;
                    player.isCharging = data.isCharging;
                    
                    // Update charging station display if player is charging
                    if (data.isCharging && player.chargingStationId) {
                        const station = document.querySelector(`.station[data-id="${player.chargingStationId}"]`);
                        if (station) {
                            station.classList.add('charging');
                        }
                    } else if (!data.isCharging && player.chargingStationId) {
                        const station = document.querySelector(`.station[data-id="${player.chargingStationId}"]`);
                        if (station) {
                            station.classList.remove('charging');
                        }
                    }
                }
            }
        });

        socket.on('resetPlayer', (data) => {
    const player = gameState.players.get(socket.id);
    if (player) {
        const station = gameState.stations[data.stationId];
        
        // Verify if the station exists
        if (station) {
            player.positionX = station.left;
            player.positionY = station.top;

            io.emit('playerReset', { 
                id: socket.id,
                positionX: player.positionX,
                positionY: player.positionY
            });
        } else {
            console.error('Invalid Station:', data.stationId);
        }
    }
});

        // Listen to 'gameState' event to update game state for players
        socket.on('gameState', (gameState) => {
        // Update charging stations
        updateStations(gameState.stations);
        // Update players
        updatePlayers(gameState.players);
});

        // Function to update stations in the game
        function updateStations(stations) {
            // Here you can update stations on the map or in the user interface
            console.log('Updated stations:', stations);
}

        // Function to update players in the game
        function updatePlayers(players) {
            // Here you can update player list or any other relevant data
        console.log('Updated players:', players);
}



        // Listen to 'playerReset' event to move the player
        socket.on('playerReset', (data) => {
            const playerCar = document.getElementById(`car-${playerId}`);
            if (playerCar) {
                playerCar.style.left = data.positionX + "px";
                playerCar.style.top = data.positionY + "px";
            }
        });

        socket.on('movePlayer', (data) => {
    const player = gameState.players.get(socket.id);
    if (player && player.energy > 0) {
        player.positionX = data.positionX;
        player.positionY = data.positionY;
        player.energy = data.energy;
        
        
        
        io.emit('playerMoved', {
            id: socket.id,
            positionX: player.positionX,
            positionY: player.positionY,
            energy: player.energy
        });
    }
});

// Add charging variables
let isCharging = false;
let chargingInterval = null;
let chargingStation = null;
// Remove the global const CHARGING_DURATION = 60000; // 60 seconds in milliseconds

// Track active chargers at each station
const activeChargers = new Map();
const chargingPlayers = new Map(); // Track which players are charging at each station

// Function that causes energy bar to gradually increase
const updateEnergyGradually = (startEnergy, targetEnergy, duration) => {
    const startTime = Date.now();
    const energyDiff = targetEnergy - startEnergy;
    
    chargingInterval = setInterval(() => {
        const elapsedTime = Date.now() - startTime;
        const progress = Math.min(elapsedTime / duration, 1);
        energy = Math.round(startEnergy + (energyDiff * progress));
        updateEnergyBar();
        
        if (progress >= 1) {
            clearInterval(chargingInterval);
            isCharging = false;
            chargingInterval = null;
            
            // Show notification when fully charged
            showNotification('Car is fully charged!');
            
            if (chargingStation) {
                const currentChargers = activeChargers.get(chargingStation) || 0;
                activeChargers.set(chargingStation, Math.max(0, currentChargers - 1));
                
                // Move car back to original position
                const playerCar = document.getElementById(`car-${playerId}`);
                if (playerCar) {
                    carPositionX = parseInt(playerCar.dataset.originalX);
                    carPositionY = parseInt(playerCar.dataset.originalY);
                    playerCar.style.left = `${carPositionX}px`;
                    playerCar.style.top = `${carPositionY}px`;
                    
                    // Emit the new position to all players
                    socket.emit('playerMoved', {
                        positionX: carPositionX,
                        positionY: carPositionY,
                        energy: energy,
                        isCharging: false
                    });
                    
                    // Clear stored position
                    delete playerCar.dataset.originalX;
                    delete playerCar.dataset.originalY;
                }
                
                const stationPlayers = chargingPlayers.get(chargingStation) || new Set();
                stationPlayers.delete(playerId);
                chargingPlayers.set(chargingStation, stationPlayers);
                
                socket.emit('chargingComplete', {
                    stationId: chargingStation.dataset.id,
                    currentChargers: Math.max(0, currentChargers - 1),
                    playerId: playerId,
                    positionX: carPositionX,
                    positionY: carPositionY
                });
                
                chargingStation.classList.remove('charging');
                chargingStation = null;

                // Remove cancel button and charging time display
                const cancelButton = document.querySelector('.cancel-charge-button');
                if (cancelButton) {
                    cancelButton.remove();
                }
                const chargingTimeDisplay = document.querySelector('.charging-time');
                if (chargingTimeDisplay) {
                    chargingTimeDisplay.remove();
                }
            }
        }
    }, 100); // Update every 100ms for smooth animation
};

// Update socket event handlers
socket.on('playerMoved', (data) => {
    const playerCar = document.getElementById(`car-${data.id}`);
    if (playerCar) {
        // Update position regardless of charging state
        playerCar.style.left = data.positionX + "px";
        playerCar.style.top = data.positionY + "px";
        
        if (players.has(data.id)) {
            const player = players.get(data.id);
            player.energy = data.energy;
            player.isCharging = data.isCharging;
            
            // Update charging station display if player is charging
            if (data.isCharging && player.chargingStationId) {
                const station = document.querySelector(`.station[data-id="${player.chargingStationId}"]`);
                if (station) {
                    station.classList.add('charging');
                }
            } else if (!data.isCharging && player.chargingStationId) {
                const station = document.querySelector(`.station[data-id="${player.chargingStationId}"]`);
                if (station) {
                    station.classList.remove('charging');
                }
            }
        }
    }
});

// Update validateSocketAvailability function
const validateSocketAvailability = (station) => {
    const maxSockets = parseInt(station.dataset.sockets, 10);
    const currentChargers = activeChargers.get(station) || 0;
    const cost = parseInt(station.dataset.cost, 10);
    
    // Check if player has enough money
    if (money < cost) {
        alert('Not enough money to charge!');
        return;
    }
    
    // Check with server before allowing charge
    socket.emit('validateCharging', {
        stationId: station.dataset.id,  // Use dataset.id instead of id
        currentChargers: currentChargers,
        playerId: playerId,
        cost: cost
    });
};

// Update socket event handlers for charging
socket.on('chargingValidation', (data) => {
    const station = document.querySelector(`.station[data-id="${data.stationId}"]`);
    if (station && data.canCharge) {
        // Update local state
        activeChargers.set(station, data.currentChargers);
        const stationPlayers = chargingPlayers.get(station) || new Set();
        stationPlayers.add(playerId);
        chargingPlayers.set(station, stationPlayers);
        
        // Start charging process
        startCharging(station);
    } else if (station) {
        // Show error message
        const errorDisplay = document.createElement('div');
        errorDisplay.className = 'charging-time';
        errorDisplay.textContent = data.message || 'Cannot charge at this station';
        errorDisplay.style.position = 'absolute';
        errorDisplay.style.top = `${parseInt(station.style.top) - 70}px`; // Move up to avoid charge button
        errorDisplay.style.left = `${parseInt(station.style.left)}px`;
        errorDisplay.style.backgroundColor = 'rgba(255, 0, 0, 0.9)';
        errorDisplay.style.padding = '2px 5px';
        errorDisplay.style.borderRadius = '3px';
        errorDisplay.style.fontSize = '12px';
        errorDisplay.style.zIndex = '999'; // Ensure it's above other elements
        map.appendChild(errorDisplay);
        
        setTimeout(() => {
            if (errorDisplay.parentNode) {
                errorDisplay.parentNode.removeChild(errorDisplay);
            }
        }, 3000);
    }
});

// Update createCancelButton function
const createCancelButton = (station) => {
    const cancelButton = document.createElement('button');
    cancelButton.className = 'cancel-charge-button';
    cancelButton.textContent = 'Cancel Charging';
    cancelButton.style.top = `${parseInt(station.style.top) - 40}px`;
    cancelButton.style.left = `${parseInt(station.style.left)}px`;
    
    cancelButton.addEventListener('click', () => {
        // Emit buttonClick event for cancel charging
        socket.emit('buttonClick', {
            playerId: playerId,
            button: 'cancelCharging',
            stationId: station.dataset.id,
            timestamp: Date.now()
        });
        // Stop charging process
        isCharging = false;
        if (chargingInterval) {
            clearInterval(chargingInterval);
            chargingInterval = null;
        }
        
        // Move car back to original position
        const playerCar = document.getElementById(`car-${playerId}`);
        if (playerCar) {
            carPositionX = parseInt(playerCar.dataset.originalX);
            carPositionY = parseInt(playerCar.dataset.originalY);
            playerCar.style.left = `${carPositionX}px`;
            playerCar.style.top = `${carPositionY}px`;
            
            // Emit the new position to all players
            socket.emit('chargingStop', {
                stationId: station.dataset.id,
                currentChargers: activeChargers.get(station) || 0,
                playerId: playerId,
                positionX: carPositionX,
                positionY: carPositionY
            });
            
            // Clear stored position
            delete playerCar.dataset.originalX;
            delete playerCar.dataset.originalY;
        }
        
        // Update charging station state
        const currentChargers = activeChargers.get(station) || 0;
        const stationPlayers = chargingPlayers.get(station) || new Set();
        stationPlayers.delete(playerId);
        chargingPlayers.set(station, stationPlayers);
        activeChargers.set(station, Math.max(0, currentChargers - 1));
        
        // Remove charging animation
        station.classList.remove('charging');
        chargingStation = null;
        
        // Remove cancel button and any charging time displays
        const cancelButton = document.querySelector('.cancel-charge-button');
        if (cancelButton) {
            cancelButton.remove();
        }
        const chargingTimeDisplay = document.querySelector('.charging-time');
        if (chargingTimeDisplay) {
            chargingTimeDisplay.remove();
        }
    });
    
    return cancelButton;
};

// Update socket event handlers for charging
socket.on('chargingStart', (data) => {
    const station = document.querySelector(`.station[data-id="${data.stationId}"]`);
    if (station) {
        activeChargers.set(station, data.currentChargers);
        const stationPlayers = chargingPlayers.get(station) || new Set();
        stationPlayers.add(data.playerId);
        chargingPlayers.set(station, stationPlayers);
        
        // Move the charging player's car to the correct position
        const playerCar = document.getElementById(`car-${data.playerId}`);
        if (playerCar) {
            // Store original position if not already stored
            if (!playerCar.dataset.originalX) {
                playerCar.dataset.originalX = playerCar.style.left;
                playerCar.dataset.originalY = playerCar.style.top;
            }
            
            // Hide the car icon while charging
            playerCar.style.display = 'none';
        }
        
        // Update charging display for all players
        updateChargingDisplay(station, data.currentChargers);
        
        // Add charging animation
        station.classList.add('charging');
        
        // Add cancel button if it's the current player
        if (data.playerId === playerId) {
            const cancelButton = createCancelButton(station);
            map.appendChild(cancelButton);
        }
    }
});

socket.on('chargingStop', (data) => {
    const station = document.querySelector(`.station[data-id="${data.stationId}"]`);
    if (station) {
        activeChargers.set(station, data.currentChargers);
        const stationPlayers = chargingPlayers.get(station) || new Set();
        
        // Handle forced reset (simulation start) differently
        if (data.forced) {
            // Clear all players from this station
            stationPlayers.clear();
        } else {
            // Normal charging stop - remove specific player
            stationPlayers.delete(data.playerId);
        }
        chargingPlayers.set(station, stationPlayers);
        
        // For forced reset, ensure all player cars are shown and reset
        if (data.forced) {
            // Show all cars that might be hidden due to charging
            document.querySelectorAll(`[id^="car-"]`).forEach(car => {
                if (car.style.display === 'none') {
                    car.style.display = 'flex';
                }
                // Clear any stored original positions
                delete car.dataset.originalX;
                delete car.dataset.originalY;
            });
        } else {
            // Show the specific player's car again and move it back to original position
            const playerCar = document.getElementById(`car-${data.playerId}`);
            if (playerCar) {
                playerCar.style.display = 'flex';
                playerCar.style.left = `${data.positionX}px`;
                playerCar.style.top = `${data.positionY}px`;
                delete playerCar.dataset.originalX;
                delete playerCar.dataset.originalY;
            }
        }
        
        // Update charging display for all players
        updateChargingDisplay(station, data.currentChargers);
        
        // Remove charging animation
        station.classList.remove('charging');
        
        // Remove cancel button and charging time display for forced reset or current player
        if (data.forced || data.playerId === playerId) {
            document.querySelectorAll('.cancel-charge-button').forEach(button => button.remove());
            document.querySelectorAll('.charging-time').forEach(display => display.remove());
        }
    }
});

socket.on('chargingComplete', (data) => {
    const station = document.querySelector(`.station[data-id="${data.stationId}"]`);
    if (station) {
        activeChargers.set(station, data.currentChargers);
        const stationPlayers = chargingPlayers.get(station) || new Set();
        stationPlayers.delete(data.playerId);
        chargingPlayers.set(station, stationPlayers);
        
        // Show the player's car again and move it back to original position
        const playerCar = document.getElementById(`car-${data.playerId}`);
        if (playerCar) {
            playerCar.style.display = 'flex';
            playerCar.style.left = `${data.positionX}px`;
            playerCar.style.top = `${data.positionY}px`;
            delete playerCar.dataset.originalX;
            delete playerCar.dataset.originalY;
        }
        
        // Update charging display for all players
        updateChargingDisplay(station, data.currentChargers);
        
        // Remove charging animation if no players are charging
        if (data.currentChargers === 0) {
            station.classList.remove('charging');
        }
        
        // Remove cancel button and charging time display
        const cancelButton = document.querySelector('.cancel-charge-button');
        if (cancelButton) {
            cancelButton.remove();
        }
        const chargingTimeDisplay = document.querySelector('.charging-time');
        if (chargingTimeDisplay) {
            chargingTimeDisplay.remove();
        }
    }
});

// Add movement state tracking
let isMoving = false;
let lastMoveTime = 0;
const MOVE_STOP_THRESHOLD = 500; // 500ms threshold to consider movement stopped

// Update moveCar function to track movement state
const moveCar = (direction) => {
    if (energy > 0 && !isCharging) {  // Add check for isCharging
        let moved = false;
        let newX = carPositionX;
        let newY = carPositionY;
        let rotation = 0;

        // Define valid road areas including edges
        const roads = [
            // Vertical roads
            { top: 0, left: 0, width: 30, height: 1000 },    // Left edge
            { top: 0, left: 115, width: 30, height: 1000 },  // Middle-left
            { top: 0, left: 235, width: 30, height: 1000 },  // Middle
            { top: 0, left: 355, width: 30, height: 1000 },  // Middle-right
            { top: 0, left: 470, width: 30, height: 1000 },  // Right edge
            { top: 0, left: 615, width: 30, height: 1000 },  // Right-middle
            { top: 0, left: 735, width: 30, height: 1000 },  // Right-upper
            { top: 0, left: 855, width: 30, height: 1000 },  // Right-lower
            { top: 0, left: 970, width: 30, height: 1000 },  // Far right edge
            // Horizontal roads
            { top: 0, left: 0, width: 1000, height: 30 },    // Top edge
            { top: 115, left: 0, width: 1000, height: 30 },  // Upper middle
            { top: 235, left: 0, width: 1000, height: 30 },  // Middle
            { top: 355, left: 0, width: 1000, height: 30 },  // Lower middle
            { top: 470, left: 0, width: 1000, height: 30 },  // Bottom edge
            { top: 615, left: 0, width: 1000, height: 30 },  // Bottom-middle
            { top: 735, left: 0, width: 1000, height: 30 },  // Bottom-upper
            { top: 855, left: 0, width: 1000, height: 30 },  // Bottom-lower
            { top: 970, left: 0, width: 1000, height: 30 },  // Far bottom edge
            // Entry/Exit points - now drivable
            { top: 485, left: -30, width: 30, height: 30 },  // Left entry
            { top: 485, left: 1000, width: 30, height: 30 }, // Right exit
            { top: -30, left: 485, width: 30, height: 30 },  // Top entry
            { top: 1000, left: 485, width: 30, height: 30 }, // Bottom exit
        ];

        // Propose new position based on direction
        switch (direction) {
            case 'right':
                newX += 5;
                rotation = 0;
                break;
            case 'left':
                newX -= 5;
                rotation = 0;
                break;
            case 'up':
                newY -= 5;
                rotation = 270;
                break;
            case 'down':
                newY += 5;
                rotation = 90;
                break;
        }

        // Check if new position is within any road
        const isOnRoad = roads.some(road => 
            newX >= road.left &&
            newX < road.left + road.width &&
            newY >= road.top &&
            newY < road.top + road.height
        );

        if (isOnRoad) {
            carPositionX = newX;
            carPositionY = newY;
            moved = true;
        }

        if (moved) {
            reduceEnergy();
            const playerCar = document.getElementById(`car-${playerId}`);
            if (playerCar) {
                playerCar.style.left = carPositionX + "px";
                playerCar.style.top = carPositionY + "px";
                playerCar.style.transform = `rotate(${rotation}deg)`;
            }

            checkCollision();
            checkDeliveryInteraction();

            // Track movement state
            const currentTime = Date.now();
            const wasMoving = isMoving;
            isMoving = true;
            lastMoveTime = currentTime;

            // Only emit movePlayer event if this is the start of movement
            if (!wasMoving) {
                socket.emit('movePlayer', {
                    positionX: carPositionX,
                    positionY: carPositionY,
                    energy: energy,
                    isCharging: false,
                    timestamp: currentTime,
                    arrowKey: direction,
                    action: 'start' // Indicate this is start of movement
                });
            } else {
                // For continuous movement, just send position update without logging
                socket.emit('movePlayer', {
                    positionX: carPositionX,
                    positionY: carPositionY,
                    energy: energy,
                    isCharging: false,
                    timestamp: currentTime,
                    arrowKey: direction,
                    action: 'continue' // Indicate this is continuous movement
                });
            }
        }
    } else if (isCharging) {
        console.log("Cannot move while charging!");
    } else {
        console.log("Your energy has run out! You cannot move.");
    }
};

// Add function to check if movement has stopped
const checkMovementStop = () => {
    if (isMoving && (Date.now() - lastMoveTime) > MOVE_STOP_THRESHOLD) {
        isMoving = false;
        // Emit stop movement event
        socket.emit('movePlayer', {
            positionX: carPositionX,
            positionY: carPositionY,
            energy: energy,
            isCharging: false,
            timestamp: Date.now(),
            action: 'stop' // Indicate this is stop of movement
        });
    }
};

// Check for movement stop periodically
setInterval(checkMovementStop, 100);

// Update keyboard controls to pass the correct arrow key
window.addEventListener('keydown', (event) => {
    switch(event.key) {
        case 'ArrowRight':
            moveCar('right');
            break;
        case 'ArrowLeft':
            moveCar('left');
            break;
        case 'ArrowUp':
            moveCar('up');
            break;
        case 'ArrowDown':
            moveCar('down');
            break;
    }
});

// Function to update the energy bar
const updateEnergyBar = () => {
    energyBar.style.width = energy + "%"; // Adjust the width of the energy bar
};

// Function to update the money indicator
const updateMoneyIndicator = () => {
    moneyIndicator.textContent = `Budget: $${money}`; // Update the money text
};

// Reduce energy with movement, more slowly
const reduceEnergy = () => {
    if (energy > 0) {
        energy -= 0.625;  // Reduce energy to allow 800 pixels travel (100 energy / 160 moves = 0.625 per move)
        updateEnergyBar();  // Update energy bar
        
        // Show notification when energy runs out
        if (energy <= 0) {
            energy = 0; // Ensure energy doesn't go below 0
            showNotification('Car is out of energy!', 'error');
        }
    }
};

// Function to create charging stations from server data
const createChargingStationsFromServer = (stations) => {
    // Keep track of used parking lot rectangles to avoid overlaps
    const usedParkingRects = [];

    // Sort stations by their position to ensure consistent parking lot assignment
    stations.sort((a, b) => {
        if (a.top === b.top) {
            return a.left - b.left;
        }
        return a.top - b.top;
    });

    stations.forEach(station => {
        // Use the chargeTime provided by the server
        const chargeTime = station.chargeTime;
        // Create the station element
        const stationElement = document.createElement('div');
        stationElement.className = 'station';
        stationElement.style.top = `${station.top}px`;
        stationElement.style.left = `${station.left}px`;
        stationElement.dataset.cost = station.cost;
        stationElement.dataset.sockets = station.sockets;
        stationElement.dataset.id = station.id;
        stationElement.dataset.chargeTime = chargeTime; // Store charge time in dataset

        // Add charging station icon
        const stationIcon = document.createElement('i');
        stationIcon.className = 'fas fa-charging-station';
        stationElement.appendChild(stationIcon);

        // Find a parking position close to the station
        const parkingPosition = findClosestParkingPosition(station, usedParkingRects);
        
        if (parkingPosition) {
            // Store the rectangle for overlap checking (x, y, width, height)
            usedParkingRects.push({
                x: parkingPosition.x,
                y: parkingPosition.y,
                width: 25,
                height: 25
            });
            
            // Create parking lot
            const parkingLot = document.createElement('div');
            parkingLot.className = 'parking-lot';
            parkingLot.style.top = `${parkingPosition.y}px`;
            parkingLot.style.left = `${parkingPosition.x}px`;

            // Create parking count indicator
            const parkingCount = document.createElement('div');
            parkingCount.className = 'parking-count';
            parkingCount.textContent = '0/' + station.sockets;
            parkingLot.appendChild(parkingCount);

            // Create only one parking spot (regardless of station sockets)
            const spot = document.createElement('div');
            spot.className = 'parking-spot';
            spot.dataset.index = 0;
            const carIcon = document.createElement('i');
            carIcon.className = 'fas fa-car';
            spot.appendChild(carIcon);
            
            // Add click event listener for charging
            spot.addEventListener('click', () => {
                const cost = parseInt(stationElement.dataset.cost, 10);
                const maxSockets = parseInt(stationElement.dataset.sockets, 10);
                const currentChargers = activeChargers.get(stationElement) || 0;
                const stationPlayers = chargingPlayers.get(stationElement) || new Set();
                const isAlreadyCharging = stationPlayers.has(playerId);

                // Only allow charging if not already charging and has enough money
                if (!isCharging && !isAlreadyCharging && money >= cost) {
                    // Emit buttonClick event with timestamp
                    socket.emit('buttonClick', {
                        playerId: playerId,
                        button: 'charge',
                        stationId: stationElement.dataset.id,
                        timestamp: Date.now()
                    });
                    validateSocketAvailability(stationElement);
                } else if (money < cost) {
                    alert('Not enough money to charge!');
                } else if (isAlreadyCharging) {
                    alert('You are already charging at this station!');
                }
            });
            
            parkingLot.appendChild(spot);

            // Create the station info panel (initially hidden)
            const infoPanel = document.createElement('div');
            infoPanel.className = 'station-info-panel';
            
            // Calculate position to keep panel within map boundaries
            const panelWidth = 220; // max-width from CSS
            const panelHeight = 120; // approximate height
            const mapWidth = 800; // map width
            const mapHeight = 600; // map height
            
            let panelLeft = station.left;
            let panelTop = station.top + 40; // Position below the station
            
            // Adjust horizontal position to keep panel within map
            if (panelLeft + panelWidth > mapWidth) {
                panelLeft = mapWidth - panelWidth - 10; // 10px margin from edge
            }
            if (panelLeft < 10) {
                panelLeft = 10; // 10px margin from left edge
            }
            
            // Adjust vertical position to keep panel within map
            if (panelTop + panelHeight > mapHeight) {
                panelTop = station.top - panelHeight - 10; // Position above station
            }
            if (panelTop < 10) {
                panelTop = 10; // 10px margin from top edge
            }
            
            infoPanel.style.left = `${panelLeft}px`;
            infoPanel.style.top = `${panelTop}px`;
            infoPanel.style.display = 'none';

            // Create button container for 2x2 grid
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'button-container';

            // Create the 4 buttons
            const priceButton = document.createElement('button');
            priceButton.className = 'station-info-button price';
            priceButton.textContent = 'Price';

            const timeButton = document.createElement('button');
            timeButton.className = 'station-info-button time';
            timeButton.textContent = 'Time';

            const socketsButton = document.createElement('button');
            socketsButton.className = 'station-info-button sockets';
            socketsButton.textContent = 'Sockets';

            const statusButton = document.createElement('button');
            statusButton.className = 'station-info-button status';
            statusButton.textContent = 'Status';

            // Create info display area
            const infoDisplay = document.createElement('div');
            infoDisplay.className = 'station-info-display';
            infoDisplay.textContent = 'Click a button to see station information';

            // Add buttons to container in 2x2 grid
            buttonContainer.appendChild(priceButton);
            buttonContainer.appendChild(timeButton);
            buttonContainer.appendChild(socketsButton);
            buttonContainer.appendChild(statusButton);

            // Add container and display to panel
            infoPanel.appendChild(buttonContainer);
            infoPanel.appendChild(infoDisplay);

            // Add click event to show/hide info panel
            stationElement.addEventListener('click', () => {
                document.querySelectorAll('.station-info-panel').forEach(panel => {
                    panel.style.display = 'none';
                });
                infoPanel.style.display = infoPanel.style.display === 'none' ? 'block' : 'none';
            });

            // Add click event to document to hide info panel when clicking outside
            document.addEventListener('click', (event) => {
                if (!stationElement.contains(event.target) && !infoPanel.contains(event.target)) {
                    infoPanel.style.display = 'none';
                }
            });

            // Add button click handlers
            priceButton.addEventListener('click', () => {
                const currentChargers = activeChargers.get(stationElement) || 0;
                const availableSockets = station.sockets - currentChargers;
                infoDisplay.innerHTML = `Cost to Charge: $${station.cost}<br>Available Sockets: ${availableSockets}`;
                
                // Log the button click event
                socket.emit('buttonClick', {
                    playerId: playerId,
                    button: 'stationInfo',
                    infoType: 'price',
                    stationId: stationElement.dataset.id,
                    stationCost: station.cost,
                    availableSockets: availableSockets,
                    timestamp: Date.now()
                });
            });

            timeButton.addEventListener('click', () => {
                infoDisplay.innerHTML = `Charge Time: ${stationElement.dataset.chargeTime} seconds<br>Full charge duration`;
                
                // Log the button click event
                socket.emit('buttonClick', {
                    playerId: playerId,
                    button: 'stationInfo',
                    infoType: 'time',
                    stationId: stationElement.dataset.id,
                    chargeTime: stationElement.dataset.chargeTime,
                    timestamp: Date.now()
                });
            });

            socketsButton.addEventListener('click', () => {
                const currentChargers = activeChargers.get(stationElement) || 0;
                const availableSockets = station.sockets - currentChargers;
                infoDisplay.innerHTML = `Total Sockets: ${station.sockets}<br>Available: ${availableSockets}<br>In Use: ${currentChargers}`;
                
                // Log the button click event
                socket.emit('buttonClick', {
                    playerId: playerId,
                    button: 'stationInfo',
                    infoType: 'sockets',
                    stationId: stationElement.dataset.id,
                    totalSockets: station.sockets,
                    availableSockets: availableSockets,
                    currentChargers: currentChargers,
                    timestamp: Date.now()
                });
            });

            statusButton.addEventListener('click', () => {
                const currentChargers = activeChargers.get(stationElement) || 0;
                const availableSockets = station.sockets - currentChargers;
                let statusText = '';
                let statusType = '';
                if (currentChargers === 0) {
                    statusText = 'Status: Available<br>No cars charging';
                    statusType = 'available';
                } else if (availableSockets > 0) {
                    statusText = `Status: Partially Occupied<br>${currentChargers} car(s) charging`;
                    statusType = 'partially_occupied';
                } else {
                    statusText = 'Status: Full<br>All sockets occupied';
                    statusType = 'full';
                }
                infoDisplay.innerHTML = statusText;
                
                // Log the button click event
                socket.emit('buttonClick', {
                    playerId: playerId,
                    button: 'stationInfo',
                    infoType: 'status',
                    stationId: stationElement.dataset.id,
                    stationStatus: statusType,
                    currentChargers: currentChargers,
                    availableSockets: availableSockets,
                    timestamp: Date.now()
                });
            });

            // Add the station, parking lot, and info panel to the map
            map.appendChild(stationElement);
            map.appendChild(parkingLot);
            map.appendChild(infoPanel);
        }
    });
};

// Function to check if two rectangles overlap
function rectsOverlap(r1, r2) {
    return (
        r1.x < r2.x + r2.width &&
        r1.x + r1.width > r2.x &&
        r1.y < r2.y + r2.height &&
        r1.y + r1.height > r2.y
    );
}

// Function to find the closest available parking position to a station
const findClosestParkingPosition = (station, usedParkingRects) => {
    const stationX = station.left;
    const stationY = station.top;
    const lotWidth = 25;
    const lotHeight = 25;
    
    // Define possible parking positions around the station (in order of preference)
    const possiblePositions = [
        // Very close positions (preferred)
        { x: stationX + 40, y: stationY },      // Right of station
        { x: stationX - 40, y: stationY },      // Left of station
        { x: stationX, y: stationY + 40 },      // Below station
        { x: stationX, y: stationY - 40 },      // Above station
        // Diagonal positions (if close ones are taken)
        { x: stationX + 40, y: stationY + 40 }, // Bottom-right
        { x: stationX - 40, y: stationY + 40 }, // Bottom-left
        { x: stationX + 40, y: stationY - 40 }, // Top-right
        { x: stationX - 40, y: stationY - 40 }, // Top-left
        // Slightly further positions (fallback)
        { x: stationX + 60, y: stationY },      // Further right
        { x: stationX - 60, y: stationY },      // Further left
        { x: stationX, y: stationY + 60 },      // Further below
        { x: stationX, y: stationY - 60 },      // Further above
    ];

    // Check each position in order of preference
    for (const pos of possiblePositions) {
        // Check if position is within map bounds
        if (pos.x < 0 || pos.x > 965 || pos.y < 0 || pos.y > 965) continue;
        // Check if position is not on a road
        if (isPositionOnRoad(pos.x, pos.y)) continue;
        // Check for overlap with any existing parking lot
        const newRect = { x: pos.x, y: pos.y, width: lotWidth, height: lotHeight };
        let overlaps = false;
        for (const rect of usedParkingRects) {
            if (rectsOverlap(newRect, rect)) {
                overlaps = true;
                break;
            }
        }
        if (!overlaps) {
            return pos;
        }
    }
    // If no suitable position found, return null
    return null;
};

// Function to check if a position is on a road
const isPositionOnRoad = (x, y) => {
    const lotWidth = 25;
    const lotHeight = 25;
    const roads = [
        // Vertical roads
        { top: 0, left: 115, width: 30, height: 1000 },
        { top: 0, left: 235, width: 30, height: 1000 },
        { top: 0, left: 355, width: 30, height: 1000 },
        { top: 0, left: 615, width: 30, height: 1000 },
        { top: 0, left: 735, width: 30, height: 1000 },
        { top: 0, left: 855, width: 30, height: 1000 },
        { top: 0, left: 970, width: 30, height: 1000 },
        // Horizontal roads
        { top: 115, left: 0, width: 1000, height: 30 },
        { top: 235, left: 0, width: 1000, height: 30 },
        { top: 355, left: 0, width: 1000, height: 30 },
        { top: 470, left: 0, width: 1000, height: 30 },
        { top: 615, left: 0, width: 1000, height: 30 },
        { top: 735, left: 0, width: 1000, height: 30 },
        { top: 855, left: 0, width: 1000, height: 30 },
        { top: 970, left: 0, width: 1000, height: 30 }
    ];

    // Check if any part of the parking lot rectangle overlaps with any road
    return roads.some(road =>
        x < road.left + road.width &&
        x + lotWidth > road.left &&
        y < road.top + road.height &&
        y + lotHeight > road.top
    );
};






    // Update the style on the map
    const playerCar = document.getElementById(`car-${playerId}`);
    if (playerCar) {
        playerCar.style.left = carPositionX + 'px';
        playerCar.style.top = carPositionY + 'px';
    }

    // Emit the reset event to the server
    socket.emit('resetPlayer', {
        positionX: carPositionX,
        positionY: carPositionY
    });




  

    // Function to get random spawn position at entry points
    const getRandomSpawnPosition = () => {
        const spawnPoints = [
            { x: 485, y: -15, pointNumber: 1 },    // Entry Point 1 (Top)
            { x: 1015, y: 485, pointNumber: 2 },   // Entry Point 2 (Right)
            { x: 485, y: 1015, pointNumber: 3 },   // Entry Point 3 (Bottom)
            { x: -15, y: 485, pointNumber: 4 }     // Entry Point 4 (Left)
        ];
        
        return spawnPoints[Math.floor(Math.random() * spawnPoints.length)];
    };

    // Add reset button event listener
    document.getElementById('reset-button').addEventListener('click', () => {
        // Emit buttonClick event with timestamp
        socket.emit('buttonClick', {
            playerId: playerId,
            button: 'reset',
            timestamp: Date.now()
        });
        
        // Reset to original starting point if available, otherwise use random spawn
        if (originalStartingPoint && hasItem) {
            // Reset to where player started with current delivery item
            carPositionX = originalStartingPoint.x;
            carPositionY = originalStartingPoint.y;
        } else {
            // Fallback to random spawn if no original starting point
            const spawnPosition = getRandomSpawnPosition();
            carPositionX = spawnPosition.x;
            carPositionY = spawnPosition.y;
        }
        
        // Reset energy only (keep money and delivery state)
        energy = 100;
        
        // Update UI
        updateEnergyBar();
        updateMoneyIndicator();
        updateItemIndicator();
        
        // Keep current delivery item and destination (don't reset delivery state)
        // Re-highlight the current destination if player has an item
        if (hasItem && currentItem) {
            highlightDestination(currentItem.destinationId);
            showNotification(`Reset to starting point! Continue delivery to ${currentItem.destinationName}`, 'info');
        }
        
        // Update car position
        const playerCar = document.getElementById(`car-${playerId}`);
        if (playerCar) {
            playerCar.style.left = carPositionX + "px";
            playerCar.style.top = carPositionY + "px";
        }
        
        // Emit reset event to server
        socket.emit('resetPlayer', {
            positionX: carPositionX,
            positionY: carPositionY,
            energy: energy,
            money: money
        });
    });

    // Add function to find nearest non-road square
    const findNearestNonRoadSquare = (stationX, stationY) => {
        // Define possible positions around the station (excluding road positions)
        const possiblePositions = [
            { x: stationX - 40, y: stationY }, // left
            { x: stationX + 40, y: stationY }, // right
            { x: stationX, y: stationY - 40 }, // up
            { x: stationX, y: stationY + 40 }  // down
        ];

        // Filter out positions that are on roads
        const roads = [
            // Vertical roads
            { top: 0, left: 115, width: 30, height: 1000 },
            { top: 0, left: 235, width: 30, height: 1000 },
            { top: 0, left: 355, width: 30, height: 1000 },
            { top: 0, left: 615, width: 30, height: 1000 },
            { top: 0, left: 735, width: 30, height: 1000 },
            { top: 0, left: 855, width: 30, height: 1000 },
            { top: 0, left: 970, width: 30, height: 1000 },
            // Horizontal roads
            { top: 115, left: 0, width: 1000, height: 30 },
            { top: 235, left: 0, width: 1000, height: 30 },
            { top: 355, left: 0, width: 1000, height: 30 },
            { top: 470, left: 0, width: 1000, height: 30 },
            { top: 615, left: 0, width: 1000, height: 30 },
            { top: 735, left: 0, width: 1000, height: 30 },
            { top: 855, left: 0, width: 1000, height: 30 },
            { top: 970, left: 0, width: 1000, height: 30 }
        ];

        // Find the first position that's not on a road
        for (const pos of possiblePositions) {
            const isOnRoad = roads.some(road => 
                pos.x >= road.left &&
                pos.x < road.left + road.width &&
                pos.y >= road.top &&
                pos.y < road.top + road.height
            );

            if (!isOnRoad) {
                return pos;
            }
        }

        // If no non-road position found, return the original position
        return { x: stationX, y: stationY };
    };

    // Update checkCollision function
    const checkCollision = () => {
        const stations = document.querySelectorAll('.station');
        const car = document.getElementById(`car-${playerId}`);
        if (!car) return;

        const carRect = car.getBoundingClientRect();
        let isCollidingWithAny = false;

        // Remove all existing charge buttons first
        document.querySelectorAll('.charge-button').forEach(button => button.remove());

        stations.forEach(station => {
            const stationRect = station.getBoundingClientRect();

            // Calculate car center
            const carCenterX = carRect.left + carRect.width / 2;
            const carCenterY = carRect.top + carRect.height / 2;

            // Check collision with tolerance
            const tolerance = 5;
            const isColliding =
                carCenterX >= stationRect.left - tolerance &&
                carCenterX <= stationRect.right + tolerance &&
                carCenterY >= stationRect.top - tolerance &&
                carCenterY <= stationRect.bottom + tolerance;

            if (isColliding) {
                isCollidingWithAny = true;
                const cost = parseInt(station.dataset.cost, 10);
                const maxSockets = parseInt(station.dataset.sockets, 10);
                const currentChargers = activeChargers.get(station) || 0;
                const stationPlayers = chargingPlayers.get(station) || new Set();
                const isAlreadyCharging = stationPlayers.has(playerId);

                // Create charge button if not already charging
                if (!isCharging && !isAlreadyCharging) {
                    const chargeButton = document.createElement('button');
                    chargeButton.className = 'charge-button';
                    chargeButton.textContent = `Charge ($${cost})`;
                    chargeButton.style.top = `${parseInt(station.style.top) - 40}px`;
                    chargeButton.style.left = `${parseInt(station.style.left)}px`;
                    
                    // Disable button if not enough money
                    if (money < cost) {
                        chargeButton.disabled = true;
                        chargeButton.title = 'Not enough money';
                    }

                    chargeButton.addEventListener('click', () => {
                        if (money >= cost) {
                            // Emit buttonClick event with timestamp
                            socket.emit('buttonClick', {
                                playerId: playerId,
                                button: 'charge',
                                stationId: station.dataset.id,
                                timestamp: Date.now()
                            });
                            validateSocketAvailability(station);
                        }
                    });

                    map.appendChild(chargeButton);
                }
            }
        });

        // If not colliding with any station and was charging, stop charging
        if (!isCollidingWithAny && isCharging) {
            isCharging = false;
            if (chargingInterval) {
                clearInterval(chargingInterval);
                chargingInterval = null;
            }
            // Remove player from active chargers when leaving
            if (chargingStation) {
                const currentChargers = activeChargers.get(chargingStation) || 0;
                const stationPlayers = chargingPlayers.get(chargingStation) || new Set();
                
                // Only decrement if player was actually charging
                if (stationPlayers.has(playerId)) {
                    activeChargers.set(chargingStation, Math.max(0, currentChargers - 1));
                    stationPlayers.delete(playerId);
                    chargingPlayers.set(chargingStation, stationPlayers);
                    
                    // Emit charging stop to all players
                    socket.emit('chargingStop', {
                        stationId: chargingStation.dataset.id,  // Use dataset.id instead of id
                        currentChargers: Math.max(0, currentChargers - 1),
                        playerId: playerId
                    });
                }
                chargingStation.classList.remove('charging');
                chargingStation = null;
            }
        }
    };

    // Update findChargingPosition function to handle multiple cars
    const findChargingPosition = (station, currentChargers) => {
        const stationX = parseInt(station.style.left);
        const stationY = parseInt(station.style.top);
        
        // Define possible charging positions relative to the station
        const chargingPositions = [
            { x: stationX - 40, y: stationY - 40 }, // top-left
            { x: stationX + 40, y: stationY - 40 }, // top-right
            { x: stationX - 40, y: stationY + 40 }, // bottom-left
            { x: stationX + 40, y: stationY + 40 }  // bottom-right
        ];
        
        // Get the position based on the number of current chargers
        const position = chargingPositions[currentChargers % chargingPositions.length];
        
        // Ensure the position is within map bounds
        position.x = Math.max(0, Math.min(position.x, mapSize - 30));
        position.y = Math.max(0, Math.min(position.y, mapSize - 30));
        
        return position;
    };

    // Update startCharging function
    const startCharging = (station) => {
        isCharging = true;
        chargingStation = station;
        
        // Store original position
        const playerCar = document.getElementById(`car-${playerId}`);
        if (playerCar) {
            playerCar.dataset.originalX = carPositionX;
            playerCar.dataset.originalY = carPositionY;
            
            // Get current number of chargers
            const currentChargers = activeChargers.get(station) || 0;
            
            // Find charging position based on current chargers
            const chargingPosition = findChargingPosition(station, currentChargers);
            
            // Move car to charging position
            carPositionX = chargingPosition.x;
            carPositionY = chargingPosition.y;
            playerCar.style.left = `${carPositionX}px`;
            playerCar.style.top = `${carPositionY}px`;
            
            // Emit the new position to all players
            socket.emit('chargingStart', {
                stationId: station.dataset.id,
                currentChargers: currentChargers,
                playerId: playerId,
                positionX: carPositionX,
                positionY: carPositionY,
                chargingIndex: currentChargers
            });
        }
        
        const cost = parseInt(station.dataset.cost, 10);
        money -= cost;
        updateMoneyIndicator();
        
        const startEnergy = energy;
        // Use the station's charge time (in seconds) for the charging duration
        const chargeTimeSeconds = parseInt(station.dataset.chargeTime, 10);
        const chargingDurationMs = chargeTimeSeconds * 1000;
        updateEnergyGradually(startEnergy, 100, chargingDurationMs);
        
        // Show charging time
        const chargingTimeDisplay = document.createElement('div');
        chargingTimeDisplay.className = 'charging-time';
        const currentChargers = activeChargers.get(station) || 0;
        const maxSockets = parseInt(station.dataset.sockets, 10);
        chargingTimeDisplay.textContent = `Charging time: ${chargeTimeSeconds} seconds (${currentChargers}/${maxSockets} sockets in use)`;
        chargingTimeDisplay.style.position = 'absolute';
        chargingTimeDisplay.style.top = `${parseInt(station.style.top) - 70}px`;
        chargingTimeDisplay.style.left = `${parseInt(station.style.left)}px`;
        chargingTimeDisplay.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
        chargingTimeDisplay.style.padding = '2px 5px';
        chargingTimeDisplay.style.borderRadius = '3px';
        chargingTimeDisplay.style.fontSize = '12px';
        chargingTimeDisplay.style.zIndex = '999';
        map.appendChild(chargingTimeDisplay);
        
        // Add cancel button
        const cancelButton = createCancelButton(station);
        map.appendChild(cancelButton);
        
        setTimeout(() => {
            if (chargingTimeDisplay.parentNode) {
                chargingTimeDisplay.parentNode.removeChild(chargingTimeDisplay);
            }
        }, 3000);

        station.classList.add('charging');
    };

    // Update updateChargingDisplay function
    const updateChargingDisplay = (station, currentChargers) => {
        const maxSockets = parseInt(station.dataset.sockets, 10);
        const availableSockets = maxSockets - currentChargers;
        
        // Update parking lot display
        const parkingLot = station.nextElementSibling;
        if (parkingLot && parkingLot.classList.contains('parking-lot')) {
            // Update parking count
            const parkingCount = parkingLot.querySelector('.parking-count');
            if (parkingCount) {
                parkingCount.textContent = `${currentChargers}/${maxSockets}`;
            }

            // Update the single parking spot
            const spot = parkingLot.querySelector('.parking-spot');
            if (spot) {
                if (currentChargers > 0) {
                    // Show car icon if any cars are charging
                    spot.classList.add('occupied');
                    const carIcon = spot.querySelector('.fa-car');
                    if (carIcon) {
                        carIcon.style.opacity = '1';
                    }
                } else {
                    // Hide car icon if no cars are charging
                    spot.classList.remove('occupied');
                    const carIcon = spot.querySelector('.fa-car');
                    if (carIcon) {
                        carIcon.style.opacity = '0';
                    }
                }
            }
        }

        // Update charging display
        const chargingDisplay = document.createElement('div');
        chargingDisplay.className = 'charging-time';
        chargingDisplay.textContent = `Charging: ${currentChargers}/${maxSockets} sockets in use`;
        chargingDisplay.style.position = 'absolute';
        chargingDisplay.style.top = `${parseInt(station.style.top) - 70}px`;
        chargingDisplay.style.left = `${parseInt(station.style.left)}px`;
        chargingDisplay.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
        chargingDisplay.style.padding = '2px 5px';
        chargingDisplay.style.borderRadius = '3px';
        chargingDisplay.style.fontSize = '12px';
        chargingDisplay.style.zIndex = '999';
        
        // Remove any existing charging display
        const existingDisplay = station.parentNode.querySelector('.charging-time');
        if (existingDisplay) {
            existingDisplay.parentNode.removeChild(existingDisplay);
        }
        
        map.appendChild(chargingDisplay);
        
        // Remove display after 3 seconds
        setTimeout(() => {
            if (chargingDisplay.parentNode) {
                chargingDisplay.parentNode.removeChild(chargingDisplay);
            }
        }, 3000);
    };

    // Add notification function
    const showNotification = (message, type = 'info') => {
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        notification.style.position = 'absolute';
        notification.style.top = '50%';
        notification.style.left = '50%';
        notification.style.transform = 'translate(-50%, -50%)';
        notification.style.backgroundColor = type === 'error' ? 'rgba(255, 0, 0, 0.9)' : 'rgba(0, 255, 0, 0.9)';
        notification.style.color = 'white';
        notification.style.padding = '10px 20px';
        notification.style.borderRadius = '5px';
        notification.style.fontSize = '16px';
        notification.style.zIndex = '1000';
        notification.style.transition = 'opacity 0.3s';
        
        map.appendChild(notification);
        
        // Fade out and remove after 1.5 seconds (reduced from 3 seconds)
        setTimeout(() => {
            notification.style.opacity = '0';
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 300); // Reduced fade out time from 500ms to 300ms
        }, 1500); // Reduced from 3000ms to 1500ms
    };

    // Function to reset client state for simulation start
    const resetClientForSimulation = () => {
        // Reset delivery system state
        hasItem = false;
        currentItem = null;
        originalStartingPoint = null;
        
        // Remove any existing delivery items and highlights
        document.querySelectorAll('.delivery-item').forEach(item => item.remove());
        document.querySelectorAll('.delivery-destination').forEach(el => {
            el.classList.remove('delivery-destination');
        });
        
        // Remove any charging buttons or displays
        document.querySelectorAll('.charge-button').forEach(button => button.remove());
        document.querySelectorAll('.cancel-charge-button').forEach(button => button.remove());
        document.querySelectorAll('.charging-time').forEach(display => display.remove());
        document.querySelectorAll('.price-tag').forEach(tag => tag.style.display = 'none');
        
        // Reset charging state and ensure car is visible
        isCharging = false;
        if (chargingInterval) {
            clearInterval(chargingInterval);
            chargingInterval = null;
        }
        chargingStation = null;
        
        // Make sure the player's car is visible and not stuck in charging state
        const playerCar = document.getElementById(`car-${playerId}`);
        if (playerCar) {
            playerCar.style.display = 'flex'; // Ensure car is visible
            delete playerCar.dataset.originalX; // Clear any stored positions
            delete playerCar.dataset.originalY;
        }
        
        // Remove charging animations from all stations
        document.querySelectorAll('.station').forEach(station => {
            station.classList.remove('charging');
        });
        
        // Clear charging maps
        activeChargers.clear();
        chargingPlayers.clear();
        
        // Update UI indicators
        updateItemIndicator();
        updateEnergyBar();
        updateMoneyIndicator();
        
        console.log('Client state reset for simulation start');
    };

    // Handle simulation events
    socket.on('simulationStarted', (data) => {
        showNotification(data.message, 'success');
        // Reset client state without reloading
        resetClientForSimulation();
        
        // Update all player positions from server
        if (data.players) {
            data.players.forEach(playerData => {
                const playerCar = document.getElementById(`car-${playerData.id}`);
                if (playerCar) {
                    playerCar.style.left = playerData.positionX + "px";
                    playerCar.style.top = playerData.positionY + "px";
                }
                
                // Update current player's state if this is our player
                if (playerData.id === playerId) {
                    carPositionX = playerData.positionX;
                    carPositionY = playerData.positionY;
                    energy = playerData.energy;
                    money = playerData.money;
                    updateEnergyBar();
                    updateMoneyIndicator();
                }
            });
        }
        
        // Start with a new delivery item after reset
        setTimeout(() => {
            startWithInitialItem();
        }, 1000);
    });

    socket.on('simulationInProgress', (data) => {
        // Show message that simulation is in progress and disconnect user
        document.body.innerHTML = `
            <div style="
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 100vh;
                background-color: #f0f0f0;
                font-family: Arial, sans-serif;
                text-align: center;
                padding: 20px;
            ">
                <h1 style="color: #FF9800; font-size: 48px; margin-bottom: 20px;">
                    Simulation In Progress
                </h1>
                <p style="font-size: 24px; color: #666; margin-bottom: 30px;">
                    ${data.message}
                </p>
                <p style="font-size: 18px; color: #888;">
                    Please try again later when the simulation has finished.
                </p>
                <button onclick="location.reload()" style="
                    background-color: #FF9800;
                    color: white;
                    padding: 15px 30px;
                    border: none;
                    border-radius: 5px;
                    font-size: 16px;
                    cursor: pointer;
                    margin-top: 30px;
                ">
                    Try Again
                </button>
            </div>
        `;
    });

    socket.on('simulationStopped', (data) => {
        // Show simulation stopped screen
        document.body.innerHTML = `
            <div style="
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                height: 100vh;
                background-color: #f0f0f0;
                font-family: Arial, sans-serif;
                text-align: center;
                padding: 20px;
            ">
                <h1 style="color: #f44336; font-size: 48px; margin-bottom: 20px;">
                    Simulation Stopped
                </h1>
                <p style="font-size: 24px; color: #666; margin-bottom: 30px;">
                    ${data.message}
                </p>
                <p style="font-size: 18px; color: #888;">
                    Please wait for the administrator to start a new simulation.
                </p>
                <button onclick="location.reload()" style="
                    background-color: #4CAF50;
                    color: white;
                    padding: 15px 30px;
                    border: none;
                    border-radius: 5px;
                    font-size: 16px;
                    cursor: pointer;
                    margin-top: 30px;
                ">
                    Refresh Page
                </button>
            </div>
        `;
    });

    </script>
</body>
</html>
